var Iterable=function(){"use strict";const t=Symbol.iterator,n=t=>"function"==typeof t,r=t=>"number"==typeof t,e=t=>null==t,i=r=>!e(r)&&n(r[t]);class o extends TypeError{constructor(t,n,r){super(),this.message=`bad argument #${t} to ${n} (${r} expected)`}}const s=(t,n,r)=>{if(!i(t))throw new o(n,r,"Iterable")},c=(t,r,e)=>{if(!n(t))throw new o(r,e,"function")},u=(t,n,e)=>{if(!r(t))throw new o(n,e,"number")},a=(t,n,r)=>{if(u(t,n,r),t<0)throw new o(n,r,"positive number")},f=(t,n,r)=>{s(t,1,r),c(n,2,r)},l=(t,n,r)=>{s(t,1,r),a(n,2,r)},h=(t,n,r)=>{s(t,1,r),s(n,2,r)},d=t=>`Iterable.${t}`,y=d("all");var p=(t,n)=>(f(t,n,y),new Gn(function*(){for(const r of t)if(!n(r))return void(yield!1);yield!0}));const v=d("any");var w=(t,n)=>(f(t,n,v),new Gn(function*(){for(const r of t)if(n(r))return void(yield!0);yield!1}));const m=d("average");var k=t=>(s(t,m),new Gn(function*(){let n=0,r=0;for(const e of t)n+=e,r+=1;yield n/r}));const b=d("breadthFirst");var g=t=>(s(t,1,b),new Gn(function*(){const n=[];for(n.push(t);0!==n.length;){const t=n.shift();if(i(t))for(const r of t)n.push(r);else yield t}}));const W=d("takeUntil");var A=(t,n)=>(f(t,n,W),new Gn(function*(){for(const r of t){if(n(r))return;yield r}}));const x=d("skipUntil");var I=(t,n)=>(f(t,n,x),new Gn(function*(){let r=!0;for(const e of t)r&&(r=!n(e)),r||(yield e)}));const E=d("breakWith");var J=(t,n)=>(f(t,n,E),[A(t,n),I(t,n)]);const F=d("buffer");var M=(t,n)=>(l(t,n,F),new Gn(function*(){let r=[];for(const e of t)r.push(e),r.length===n&&(yield r,r=[]);r.length>0&&(yield r)}));const L=d("cache");var U=t=>{s(t,1,L);const n=[];let r=0;return new Gn(function*(){if(r>0)for(const t of n)yield t;let e=r;for(const i of t)0===e?(n.push(i),r+=1,yield i):e-=1})};const j=d("compose");var R=(t,...n)=>{s(t,1,j);let r=1,e=t;for(const t of n)if(c(t,r+=1,j),e=t(e),!i(e))throw new TypeError("Iterable.compose: a composer function returned a non-Iterable.");return e instanceof Gn?e:new Gn(e)};const S=d("flat");var $=t=>(s(t,1,S),new Gn(function*(){for(const n of t)if(i(n))for(const t of n)yield t;else yield n})),q=(...t)=>$(new Gn(t));const z=d("flatMap");var D=(t,n)=>(f(t,n,z),new Gn(function*(){for(const r of t)yield n(r)}));const O=d("find");var Y=(t,n)=>(f(t,n,O),new Gn(function*(){let r=0;for(const e of t){if(n(e))return void(yield r);r+=1}yield-1}));const G=d("indexOf");var T=(t,n)=>(s(t,1,G),Y(t,t=>t===n));const P=d("contains");var B=(t,n)=>(s(t,1,P),D(T(t,n),t=>t>-1));const C=d("count");var H=t=>(s(t,1,C),new Gn(function*(){let n=0;for(const r of t)n+=1;yield n}));const K=d("defaultIfEmpty");var N=(t,n)=>(s(t,1,K),new Gn(function*(){let r=!0;for(const n of t)yield n,r=!1;r&&(yield n)}));const Q=d("depthFirst");var V=t=>(s(t,1,Q),new Gn(function*(){const n=[];n.push(t);const r=[];for(;0!==n.length;){const t=n.pop();if(i(t))for(const r of t)n.push(r);else r.push(t)}for(const t of r.reverse())yield t}));const X=d("toArray");var Z=t=>{s(t,1,X);const n=[];for(const r of t)n.push(r);return n};const _=d("diff");var tt=(t,n)=>(h(t,n,_),new Gn(function*(){const r=Z(t),e=Z(n);for(const t of r)e.includes(t)||(yield t)}));const nt=d("distinct");var rt=t=>(s(t,1,nt),new Gn(function*(){const n=[];for(const r of t)n.includes(r)||(yield r),n.push(r)}));const et=d("distinctAdjacent");var it=t=>(s(t,1,et),new Gn(function*(){let n,r=!0;for(const e of t)r?(yield e,r=!1):n!==e&&(yield e),n=e}));const ot=d("elementAt");var st=(t,n)=>(l(t,n,ot),new Gn(function*(){let r=0;for(const e of t){if(r===n)return void(yield e);r+=1}})),ct=()=>new Gn([]);const ut=d("equal");var at=(t,n)=>(h(t,n,ut),new Gn(function*(){const r=Z(t);for(const t of n)if(t!==r.shift())return void(yield!1);yield 0===r.length}));const ft=d("filter");var lt=(t,n)=>(f(t,n,ft),new Gn(function*(){for(const r of t)n(r)&&(yield r)}));const ht=d("first"),dt=()=>!0;var yt=(t,n)=>{s(t,1,ht);let r=n;return e(r)?r=dt:c(n,2,ht),new Gn(function*(){for(const n of t)if(r(n))return void(yield n)})};const pt=d("flatMap");var vt=(t,n)=>(f(t,n,pt),$(D(t,n)));const wt=d("innerJoin");var mt=(t,n)=>(h(t,n,wt),new Gn(function*(){const r=Z(t),e=Z(n);for(const t of r)e.includes(t)&&(yield t);for(const t of e)r.includes(t)&&(yield t)}));const kt=d("intercalate");var bt=(t,n)=>(h(t,n,kt),new Gn(function*(){const r=[];let e;for(const i of t){r.push(i),e=r.slice(0);for(const t of n)r.push(t)}for(const t of e)yield t}));const gt=d("intersect");var Wt=(t,n)=>(h(t,n,gt),new Gn(function*(){const r=Z(t),e=Z(n);for(const t of r)e.includes(t)&&(yield t)}));const At=d("intersperse");var xt=(t,n)=>(s(t,1,At),new Gn(function*(){const r=[];let e;for(const i of t)r.push(i),e=r.slice(0),r.push(n);for(const t of e)yield t}));const It=d("isEmpty");var Et=t=>(s(t,1,It),new Gn(function*(){for(const n of t)return void(yield!1);yield!0})),Jt=t=>new Gn([t]);const Ft=d("last"),Mt=()=>!0;var Lt=(t,n)=>{s(t,1,Ft);let r=n;return e(r)?r=Mt:c(n,2,Ft),new Gn(function*(){let n;for(const e of t)r(e)&&(n=e);yield n})};const Ut=d("leftJoin");var jt=(t,n)=>(h(t,n,Ut),new Gn(function*(){const r=Z(t),e=Z(n);for(const t of r)yield t;for(const t of e)r.includes(t)&&(yield t)}));const{max:Rt}=Math,St=d("max");var $t=t=>(s(t,St),new Gn(function*(){let n;for(const r of t)n=e(n)?r:Rt(n,r);yield n}));const{min:qt}=Math,zt=d("min");var Dt=t=>(s(t,zt),new Gn(function*(){let n;for(const r of t)n=e(n)?r:qt(n,r);yield n}));const Ot=d("onDone");var Yt=(t,n)=>(f(t,n,Ot),new Gn(function*(){for(const n of t)yield n;n()}));const Gt=d("onStart");var Tt=(t,n)=>(f(t,n,Gt),new Gn(function*(){n();for(const n of t)yield n}));const Pt=d("onYield");var Bt=(t,n)=>(f(t,n,Pt),new Gn(function*(){for(const r of t)n(r),yield r}));const Ct=d("outerJoin");var Ht=(t,n)=>(h(t,n,Ct),new Gn(function*(){const r=Z(t),e=Z(n);for(const t of r)e.includes(t)||(yield t);for(const t of e)r.includes(t)||(yield t)}));const Kt=d("partition");var Nt=(t,n)=>(f(t,n,Kt),[lt(t,n),lt(t,t=>!n(t))]);const Qt=d("range"),Vt=(t,n,r)=>{u(t,1,Qt),u(n,2,Qt);let i=r;return e(r)?i=1:u(r,3,Qt),new Gn(function*(){const r=i*Math.sign(n-t);for(let e=t;r<0?e>=n:e<=n;e+=r)yield e})},Xt=d("reduce");var Zt=(t,n,r)=>(f(t,n,Xt),new Gn(function*(){let e=r,i=null==r;for(const r of t)i?(e=r,i=!1):e=n(e,r);yield e}));const _t=d("repeat");var tn=(t,n)=>(l(t,n,_t),new Gn(function*(){for(let r=n;r>0;r-=1)for(const n of t)yield n}));const nn=d("replace");var rn=(t,n,r)=>(l(t,n,nn),new Gn(function*(){let e=0;for(const i of t)e===n?yield r:yield i,e+=1}));const en=d("reverse");var on=t=>(s(t,1,en),new Gn(function*(){const n=[];for(const r of t)n.unshift(r);for(const t of n)yield t}));const sn=d("scan");var cn=(t,n,r)=>(f(t,n,sn),new Gn(function*(){let e=r,i=null==r;for(const r of t)i?(e=r,i=!1):e=n(e,r),yield e}));const un=d("skip");var an=(t,n)=>(l(t,n,un),new Gn(function*(){let r=n;for(const n of t)r>0?r-=1:yield n}));const fn=d("skipLast");var ln=(t,n)=>(l(t,n,fn),new Gn(function*(){const r=[];let e=0;for(const i of t)n>0?(r.push(i),e===n?yield r.shift():e+=1):yield i}));const hn=d("skipWhile");var dn=(t,n)=>(f(t,n,hn),new Gn(function*(){let r=!0;for(const e of t)r&&(r=n(e)),r||(yield e)}));const yn=d("take");var pn=(t,n)=>(l(t,n,yn),new Gn(function*(){let r=n;for(const n of t){if(!(r>0))return;r-=1,yield n}}));const vn=d("slice");var wn=(t,n,r)=>(s(t,1,vn),a(n,2,vn),a(r,3,vn),an(pn(t,r),n));const mn=d("sort"),kn=(t,n)=>t-n;var bn=(t,n)=>{s(t,1,mn);let r=n;return e(r)?r=kn:c(n,2,mn),new Gn(Z(t).sort(r))};const gn=d("sorted"),Wn=(t,n)=>t-n;var An=(t,n)=>{s(t,1,gn);let r=n;return e(r)?r=Wn:c(n,2,gn),new Gn(function*(){let n;for(const e of t){if(void 0!==n&&r(n,e)>0)return void(yield!1);n=e}yield!0})};const xn=d("takeWhile");var In=(t,n)=>(f(t,n,xn),new Gn(function*(){for(const r of t){if(!n(r))return;yield r}}));const En=d("spanWith");var Jn=(t,n)=>(f(t,n,En),[In(t,n),dn(t,n)]);const Fn=d("split");var Mn=(t,n)=>(l(t,n,Fn),[pn(t,n),an(t,n)]);const Ln=d("startWith");var Un=(t,...n)=>(s(t,1,Ln),q(...n,t));const jn=d("step");var Rn=(t,n)=>(l(t,n,jn),new Gn(function*(){if(n<1)return;let r=0;for(const e of t)r%n==0&&(yield e),r+=1}));const Sn=d("sum");var $n=t=>(s(t,Sn),new Gn(function*(){let n=0;for(const r of t)n+=r;yield n}));const qn=d("takeLast");var zn=(t,n)=>(l(t,n,qn),new Gn(function*(){if(0===n)return;const r=[];for(const n of t)r.push(n);for(const t of r.slice(-n))yield t}));const Dn=d("zip"),On=t=>t,Yn=(t,r)=>{if(!(t instanceof Array))throw new o(1,Dn,"Array");let i=r;return e(r)?i=On:n(r)||c(r,2,Dn),new Gn(function*(){const n=[];for(const r of t){let t=0;for(const i of r){let r=n[t];e(r)&&(r=[],n[t]=r),r.push(i),t+=1}}for(const t of n)yield i(t)})};class Gn{constructor(n){const e=n;if("GeneratorFunction"===e.constructor.name)e[t]=e,this.it=e;else{if(!i(e))throw new o(1,"Iterable.<constructor>","Iterable or Generator");this.it=e}return this.it=e,new Proxy(this,{get:(t,n)=>n in t?t[n]:r(n)?t.get(n):void 0})}get(t){const{it:n}=this;let r=0;for(const e of n){if(r===t)return e;r+=1}}static is(t){return i(t)}static all(t,n){return p(t,n)}all(t){return p(this.it,t)}static any(t,n){return w(t,n)}any(t){return w(this.it,t)}static average(t){return k(t)}average(){return k(this.it)}static breadthFirst(t){return g(t)}breadthFirst(){return g(this.it)}static buffer(t,n){return M(t,n)}buffer(t){return M(this.it,t)}static breakWith(t,n){return J(t,n)}breakWith(t){return J(this.it,t)}static cache(t){return U(t)}cache(){return U(this.it)}static compose(t,...n){return R(t,...n)}compose(...t){return R(this.it,...t)}static concat(...t){return q(...t)}concat(...t){return q(this.it,...t)}static contains(t,n){return B(t,n)}contains(t){return B(this.it,t)}static count(t){return H(t)}count(){return H(this.it)}static defaultIfEmpty(t,n){return N(t,n)}defaultIfEmpty(t){return N(this.it,t)}static depthFirst(t){return V(t)}depthFirst(){return V(this.it)}static diff(t,n){return tt(t,n)}diff(t){return tt(this.it,t)}static distinct(t){return rt(t)}distinct(){return rt(this.it)}static distinctAdjacent(t){return it(t)}distinctAdjacent(){return it(this.it)}static elementAt(t,n){return st(t,n)}elementAt(t){return st(this.it,t)}static empty(){return ct()}ignoreElements(){return ct(this)}static equal(t,n){return at(t,n)}equal(t){return at(this.it,t)}static filter(t,n){return lt(t,n)}filter(t){return lt(this.it,t)}static find(t,n){return Y(t,n)}find(t){return Y(this.it,t)}static first(t,n){return yt(t,n)}first(t){return yt(this.it,t)}static flat(t){return $(t)}flat(){return $(this.it)}static flatMap(t,n){return vt(t,n)}flatMap(t){return vt(this.it,t)}static indexOf(t,n){return T(t,n)}indexOf(t){return T(this.it,t)}static innerJoin(t,n){return mt(t,n)}innerJoin(t){return mt(this.it,t)}static intercalate(t,n){return bt(t,n)}intercalate(t){return bt(this.it,t)}static intersect(t,n){return Wt(t,n)}intersect(t){return Wt(this.it,t)}static intersperse(t,n){return xt(t,n)}intersperse(t){return xt(this.it,t)}static isEmpty(t){return Et(t)}isEmpty(){return Et(this.it)}static just(t){return Jt(t)}static last(t,n){return Lt(t,n)}last(t){return Lt(this.it,t)}static leftJoin(t,n){return jt(t,n)}leftJoin(t){return jt(this.it,t)}static map(t,n){return D(t,n)}map(t){return D(this.it,t)}static max(t){return $t(t)}max(){return $t(this.it)}static min(t){return Dt(t)}min(){return Dt(this.it)}static onDone(t,n){return Yt(t,n)}onDone(t){return Yt(this.it,t)}static onStart(t,n){return Tt(t,n)}onStart(t){return Tt(this.it,t)}static onYield(t,n){return Bt(t,n)}onYield(t){return Bt(this.it,t)}static outerJoin(t,n){return Ht(t,n)}outerJoin(t){return Ht(this.it,t)}static partition(t,n){return Nt(t,n)}partition(t){return Nt(this.it,t)}static range(t,n,r){return Vt(t,n,r)}static reduce(t,n,r){return Zt(t,n,r)}reduce(t,n){return Zt(this.it,t,n)}static reduceRight(t,n,r){return Zt(t,n,r)}reduceRight(t,n){return Zt(this.it,t,n)}static repeat(t,n){return tn(t,n)}repeat(t){return tn(this.it,t)}static replace(t,n,r){return rn(t,n,r)}replace(t,n){return rn(this.it,t,n)}static reverse(t){return on(t)}reverse(){return on(this.it)}static scan(t,n,r){return cn(t,n,r)}scan(t,n){return cn(this.it,t,n)}static scanRight(t,n,r){return cn(t,n,r)}scanRight(t,n){return cn(this.it,t,n)}static skip(t,n){return an(t,n)}skip(t){return an(this.it,t)}static skipLast(t,n){return ln(t,n)}skipLast(t){return ln(this.it,t)}static skipUntil(t,n){return I(t,n)}skipUntil(t){return I(this.it,t)}static skipWhile(t,n){return dn(t,n)}skipWhile(t){return dn(this.it,t)}static slice(t,n,r){return wn(t,n,r)}slice(t,n){return wn(this.it,t,n)}static sort(t,n){return bn(t,n)}sort(t){return bn(this.it,t)}static sorted(t,n){return An(t,n)}sorted(t){return An(this.it,t)}static spanWith(t,n){return Jn(t,n)}spanWith(t){return Jn(this.it,t)}static split(t,n){return Mn(t,n)}split(t){return Mn(this.it,t)}static startWith(t,...n){return Un(t,...n)}startWith(...t){return Un(this.it,...t)}static step(t,n){return Rn(t,n)}step(t){return Rn(this.it,t)}static sum(t){return $n(t)}sum(){return $n(this.it)}static take(t,n){return pn(t,n)}take(t){return pn(this.it,t)}static takeLast(t,n){return zn(t,n)}takeLast(t){return zn(this.it,t)}static takeUntil(t,n){return A(t,n)}takeUntil(t){return A(this.it,t)}static takeWhile(t,n){return In(t,n)}takeWhile(t){return In(this.it,t)}static toArray(t){return Z(t)}toArray(){return Z(this.it)}static zip(t,n){return Yn(t,n)}zip(t,n){return Yn([this.it,...t],n)}[t](){return this.it[t]()}}return Gn}();