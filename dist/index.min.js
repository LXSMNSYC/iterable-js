var Iterable=function(){"use strict";const t=Symbol.iterator,n=t=>"function"==typeof t,r=t=>"number"==typeof t,e=t=>null==t,i=r=>!e(r)&&n(r[t]);class o extends TypeError{constructor(t,n,r){super(),this.message=`bad argument #${t} to ${n} (${r} expected)`}}const s=(t,n,r)=>{if(!i(t))throw new o(n,r,"Iterable")},c=(t,r,e)=>{if(!n(t))throw new o(r,e,"function")},a=(t,n,e)=>{if(!r(t))throw new o(n,e,"number")},u=(t,n,r)=>{s(t,1,r),c(n,2,r)},f=(t,n,r)=>{s(t,1,r),((t,n,r)=>{if(a(t,n,r),t<=0)throw new o(n,r,"positive number")})(n,2,r)},l=(t,n,r)=>{s(t,1,r),s(n,2,r)},h=t=>`Iterable.${t}`,d=h("all");var p=(t,n)=>(u(t,n,d),new en(function*(){for(const r of t)if(!n(r))return void(yield!1);yield!0}));const y=h("any");var v=(t,n)=>(u(t,n,y),new en(function*(){for(const r of t)if(n(r))return void(yield!0);yield!1}));const w=h("takeUntil");var k=(t,n)=>(u(t,n,w),new en(function*(){for(const r of t){if(n(r))return;yield r}}));const m=h("skipUntil");var b=(t,n)=>(u(t,n,m),new en(function*(){let r=!0;for(const e of t)r&&(r=!n(e)),r||(yield e)}));const W=h("breakWith");var g=(t,n)=>(u(t,n,W),[k(t,n),b(t,n)]);const A=h("buffer");var x=(t,n)=>(f(t,n,A),new en(function*(){let r=[];for(const e of t)r.push(e),r.length===n&&(yield r,r=[]);r.length>0&&(yield r)}));const I=h("cache");var L=t=>{s(t,1,I);const n=[];let r=0;return new en(function*(){if(r>0)for(const t of n)yield t;let e=r;for(const i of t)0===e?(n.push(i),r+=1,yield i):e-=1})};const E=h("compose");var M=(t,...n)=>{s(t,1,E);let r=1,e=t;for(const t of n)if(c(t,r+=1,E),e=t(e),!i(e))throw new TypeError("Iterable.compose: a composer function returned a non-Iterable.");return e instanceof en?e:new en(e)};const j=h("flat");var S=t=>(s(t,1,j),new en(function*(){for(const n of t)if(i(n))for(const t of n)yield t;else yield n})),$=(...t)=>S(new en(t));const q=h("flatMap");var z=(t,n)=>(u(t,n,q),new en(function*(){for(const r of t)yield n(r)}));const D=h("find");var O=(t,n)=>(u(t,n,D),new en(function*(){let r=0;for(const e of t){if(n(e))return void(yield r);r+=1}yield-1}));const Y=h("indexOf");var G=(t,n)=>(s(t,1,Y),O(t,t=>t===n));const T=h("contains");var U=(t,n)=>(s(t,1,T),z(G(t,n),t=>t>-1));const F=h("count");var P=t=>(s(t,1,F),new en(function*(){let n=0;for(const r of t)n+=1;yield n}));const B=h("distinct");var C=t=>(s(t,1,B),new en(function*(){const n=[];for(const r of t)n.includes(r)||(yield r),n.push(r)}));const H=h("distinctAdjacent");var J=t=>(s(t,1,H),new en(function*(){let n,r=!0;for(const e of t)r?(yield e,r=!1):n!==e&&(yield e),n=e}));const K=h("elementAt");var N=(t,n)=>(f(t,n,K),new en(function*(){let r=0;for(const e of t){if(r===n)return void(yield e);r+=1}})),Q=()=>new en([]);const R=h("toArray");var V=t=>{s(t,1,R);const n=[];for(const r of t)n.push(r);return n};const X=h("equal");var Z=(t,n)=>(l(t,n,X),new en(function*(){const r=V(t);for(const t of n)if(t!==r.shift())return void(yield t);yield 0===r.length}));const _=h("filter");var tt=(t,n)=>(u(t,n,_),new en(function*(){for(const r of t)n(r)&&(yield r)}));const nt=h("first");var rt=t=>(s(t,1,nt),new en(function*(){for(const n of t)return void(yield n)}));const et=h("flatMap");var it=(t,n)=>(u(t,n,et),S(z(t,n)));const ot=h("reduce");var st=(t,n)=>(u(t,n,ot),new en(function*(){let r;for(const e of t)r=n(r,e);yield r}));const ct=h("intercalate");var at=(t,n)=>(l(t,n,ct),st(t,(n,r)=>{if(void 0===n)return[r];for(const r of t)n.push(r);return n.push(r),n}));const ut=h("intersect");var ft=(t,n)=>(l(t,n,ut),new en(function*(){for(const r of t)for(const t of n)r===t&&(yield r)}));const lt=h("intersperse");var ht=(t,n)=>(s(t,1,lt),st(t,(t,r)=>void 0===t?[r]:(t.push(n),t.push(r),t)));const dt=h("isEmpty");var pt=t=>(s(t,1,dt),new en(function*(){for(const n of t)return void(yield!1);yield!0})),yt=t=>new en([t]);const vt=h("last");var wt=t=>(s(t,1,vt),new en(function*(){let n;for(const r of t)n=r;yield n}));const kt=h("onDone");var mt=(t,n)=>(u(t,n,kt),new en(function*(){for(const n of t)yield n;n()}));const bt=h("onStart");var Wt=(t,n)=>(u(t,n,bt),new en(function*(){n();for(const n of t)yield n}));const gt=h("onYield");var At=(t,n)=>(u(t,n,gt),new en(function*(){for(const r of t)n(r),yield r}));const xt=h("partition");var It=(t,n)=>(u(t,n,xt),[tt(t,n),tt(t,t=>!n(t))]);const Lt=h("range"),Et=(t,n,r)=>{a(t,1,Lt),a(n,2,Lt);let i=r;return e(r)?i=1:a(r,3,Lt),new en(function*(){const r=i*Math.sign(n-t);for(let e=t;r<0?e>=n:e<=n;e+=r)yield e})},Mt=h("repeat");var jt=(t,n)=>(f(t,n,Mt),new en(function*(){for(let r=n;r>0;r-=1)for(const n of t)yield n}));const St=h("replace");var $t=(t,n,r)=>(f(t,n,St),new en(function*(){let e=0;for(const i of t)e===n?yield r:yield i,e+=1}));const qt=h("reverse");var zt=t=>(s(t,1,qt),new en(function*(){const n=[];for(const r of t)n.unshift(r);for(const t of n)yield t}));const Dt=h("skip");var Ot=(t,n)=>(f(t,n,Dt),new en(function*(){let r=n;for(const n of t)r>0?r-=1:yield n}));const Yt=h("skipLast");var Gt=(t,n)=>(f(t,n,Yt),new en(function*(){const r=[];let e=0;for(const i of t)n>0?(r.push(i),e===n?yield r.shift():e+=1):yield i}));const Tt=h("skipWhile");var Ut=(t,n)=>(u(t,n,Tt),new en(function*(){let r=!0;for(const e of t)r&&(r=n(e)),r||(yield e)}));const Ft=h("takeWhile");var Pt=(t,n)=>(u(t,n,Ft),new en(function*(){for(const r of t){if(!n(r))return;yield r}}));const Bt=h("spanWith");var Ct=(t,n)=>(u(t,n,Bt),[Pt(t,n),Ut(t,n)]);const Ht=h("take");var Jt=(t,n)=>(f(t,n,Ht),new en(function*(){let r=n;for(const n of t){if(!(r>0))return;r-=1,yield n}}));const Kt=h("split");var Nt=(t,n)=>(f(t,n,Kt),[Jt(t,n),Ot(t,n)]);const Qt=h("startWith");var Rt=(t,...n)=>(s(t,1,Qt),$(...n,t));const Vt=h("step");var Xt=(t,n)=>(f(t,n,Vt),new en(function*(){let r=0;for(const e of t)r%n==0&&(yield e),r+=1}));const Zt=h("takeLast");var _t=(t,n)=>(f(t,n,Zt),new en(function*(){const r=[];for(const e of t)0===n?yield e:r.push(e);for(const t of r.slice(-n))yield t}));const tn=h("zip"),nn=t=>t,rn=(r,s)=>{if(!(r instanceof Array))throw new o(1,tn,"Array");let a=s;e(s)?a=nn:n(s)||c(s,2,tn);const u=r.length;return new en(function*(){const n=[];let e=u,o=0;for(const s of r)i(s)?n[o]=s[t]():e-=1,o+=1;for(;e>0;){const t=[];for(let r=0;r<u;r+=1){const i=n[r];if(void 0!==i){const{value:o,done:s}=i.next();t.push(o),s&&(n[r]=void 0,e-=1)}else t.push(void 0)}yield a(t)}})};class en{constructor(n){const e=n;if("GeneratorFunction"===e.constructor.name)e[t]=e,this.it=e;else{if(!i(e))throw new o(1,"Iterable.<constructor>","Iterable or Generator");this.it=e}return this.it=e,new Proxy(this,{get:(t,n)=>n in t?t[n]:r(n)?t.get(n):void 0})}get(t){const{it:n}=this;let r=0;for(const e of n){if(r===t)return e;r+=1}}static is(t){return i(t)}static all(t,n){return p(t,n)}all(t){return p(this.it,t)}static any(t,n){return v(t,n)}any(t){return v(this.it,t)}static buffer(t,n){return x(t,n)}buffer(t){return x(this.it,t)}static breakWith(t,n){return g(t,n)}breakWith(t){return g(this.it,t)}static cache(t){return L(t)}cache(){return L(this.it)}static compose(t,...n){return M(t,...n)}compose(...t){return M(this.it,...t)}static concat(...t){return $(...t)}concat(...t){return $(this.it,...t)}static contains(t,n){return U(t,n)}contains(t){return U(this.it,t)}static count(t){return P(t)}count(){return P(this.it)}static distinct(t){return C(t)}distinct(){return C(this.it)}static distinctAdjacent(t){return J(t)}distinctAdjacent(){return J(this.it)}static elementAt(t,n){return N(t,n)}elementAt(t){return N(this.it,t)}static empty(){return Q()}static equal(t,n){return Z(t,n)}equal(t){return Z(this.it,t)}static filter(t,n){return tt(t,n)}filter(t){return tt(this.it,t)}static find(t,n){return O(t,n)}find(t){return O(this.it,t)}static first(t){return rt(t)}first(){return rt(this.it)}static flat(t){return S(t)}flat(){return S(this.it)}static flatMap(t,n){return it(t,n)}flatMap(t){return it(this.it,t)}static indexOf(t,n){return G(t,n)}indexOf(t){return G(this.it,t)}static intercalate(t,n){return at(t,n)}intercalate(t){return at(this.it,t)}static intersect(t,n){return ft(t,n)}intersect(t){return ft(this.it,t)}static intersect(t,n){return ft(t,n)}intersect(t){return ft(this.it,t)}static intersperse(t,n){return ht(t,n)}intersperse(t){return ht(this.it,t)}static isEmpty(t){return pt(t)}isEmpty(){return pt(this.it)}static just(t){return yt(t)}static last(t){return wt(t)}last(){return wt(this.it)}static map(t,n){return z(t,n)}map(t){return z(this.it,t)}static onDone(t,n){return mt(t,n)}onDone(t){return mt(this.it,t)}static onStart(t,n){return Wt(t,n)}onStart(t){return Wt(this.it,t)}static onYield(t,n){return At(t,n)}onYield(t){return At(this.it,t)}static partition(t,n){return It(t,n)}partition(t){return It(this.it,t)}static range(t,n,r){return Et(t,n,r)}static reduce(t,n){return st(t,n)}reduce(t){return st(this.it,t)}static repeat(t,n){return jt(t,n)}repeat(t){return jt(this.it,t)}static replace(t,n,r){return $t(t,n,r)}replace(t,n){return $t(this.it,t,n)}static reverse(t){return zt(t)}reverse(){return zt(this.it)}static skip(t,n){return Ot(t,n)}skip(t){return Ot(this.it,t)}static skipLast(t,n){return Gt(t,n)}skipLast(t){return Gt(this.it,t)}static skipWhile(t,n){return Ut(t,n)}skipWhile(t){return Ut(this.it,t)}static spanWith(t,n){return Ct(t,n)}spanWith(t){return Ct(this.it,t)}static split(t,n){return Nt(t,n)}split(t){return Nt(this.it,t)}static startWith(t,...n){return Rt(t,...n)}startWith(...t){return Rt(this.it,...t)}static step(t,n){return Xt(t,n)}step(t){return Xt(this.it,t)}static take(t,n){return Jt(t,n)}take(t){return Jt(this.it,t)}static takeLast(t,n){return _t(t,n)}takeLast(t){return _t(this.it,t)}static takeWhile(t,n){return Pt(t,n)}takeWhile(t){return Pt(this.it,t)}static toArray(t){return V(t)}toArray(){return V(this.it)}static zip(t,n){return rn(t,n)}zip(t,n){return rn([this.it,...t],n)}[t](){return this.it[t]()}}return en}();